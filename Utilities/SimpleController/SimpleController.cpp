/**
 *	@file SimpleController.cpp
 *
 *	@class SimpleController
 *
 *	@brief This controls execution of "Framed" models
 *
 *	@author Jack K. Lavender, Jr. <jack.lavender@lmco.com>
 *
 */


#define ISE_BUILD_DLL

#include "ISERelease.h"
#include "ISETrace.h" // first to toggle tracing


#include "SimpleController.h"
#include "SamsonHeader.h"
#include "DebugFlag.h"
#include "MessageFunctor.hpp"
#include "SimMsgType.h"
#include "Options.h"

// used to get the command line
#include "ace/Get_Opt.h"

#include "Model_ObjMgr.h"


#include "ace/Reactor.h"

using namespace Samson_Peer;


// ........................................................................................
SimpleController::SimpleController(): SamsonModel(),
start_timer_(-1),
nmodels_(0),
endGame_(false)
{
}

// ........................................................................................
// Downcall from ShareAppMgr on dll open.
int SimpleController::init(int argc, ACE_TCHAR *argv[])
{
	ACE_TRACE("SimpleController::init");

	/*
	 * These messages all declared in the AppBase class.
	 * The controller is the place where the "end" and "completed" messages need be processed
	 */

	// Receive Init Event Message (generated by a hello event sent to dispatcher)
	MessageFunctor<SimpleController>initfunctor(this,&SimpleController::doInitEvent);
	mInitEvent->subscribe(&initfunctor,0);

	// Receive End of Engagement Message
	MessageFunctor<SimpleController>endEngageFunctor(this,&SimpleController::doEndEngagement);
	mEndEngage->subscribe(&endEngageFunctor,0);

	// Receive End the Run Completed Message
	MessageFunctor<SimpleController>endruncmpfunctor(this,&SimpleController::doEndRunComplete);
	mEndRunCmp->subscribe(&endruncmpfunctor,0);


	// Fill the PeerTable
	this->nmodels_ = Samson_Peer::SAMSON_OBJMGR::instance ()->getPeerTable (run_id_,peer_table);

	// Become the Job Master
	Samson_Peer::SAMSON_OBJMGR::instance ()->setRunMaster ();

	this->timing_.set(0);  // I do not react to time
	this->schedule_start(3); // wait this long to check for all the models ready

	this->print();

	return this->SamsonModel::init(argc,argv);
}

//........................................................................................
// Schedule a timer to wait for the start
void SimpleController::schedule_start(int ntime)
{
	ACE_Time_Value const next_time (ntime);
	if ( (this->start_timer_ =  ACE_Reactor::instance ()->schedule_timer (this,  (const void *) SimpleController::STARTUP, next_time)) == -1)
		ACE_ERROR ((LM_ERROR, ACE_TEXT ("(%P|%t) %p\n"), ACE_TEXT ("schedule_timer")));
	else
	{
		ACE_DEBUG ((LM_INFO, "(%P|%t) SimpleController::schedule_start(%d)\n",ntime));
		//this->print();
	}
}



//...................................................................................................
int SimpleController::info (ACE_TCHAR **info_string, size_t length) const
{
	ACE_TRACE("SimpleController::info");
	std::stringstream myinfo;
	myinfo << *this;

	if (*info_string == 0)
		*info_string = ACE::strnew(myinfo.str().c_str());
	else
		ACE_OS::strncpy(*info_string, myinfo.str().c_str(), length);

	return ACE_OS::strlen(*info_string) +1;
}

//...................................................................................................
ostream& operator<<(ostream& output, const SimpleController& p)
{
    output << dynamic_cast< const Samson_Peer::SamsonModel&>(p) << std::endl;

    output << "SimpleController:: "
    	<< p.peer_table
     	;

    return output;
}

//...................................................................................................
// Downcall from SharedAppMgr on finish
int SimpleController::fini(void)
{
	ACE_TRACE("SimpleController::fini");
	if ( this->start_timer_ > 0 ) ACE_Reactor::instance ()->cancel_timer (this->start_timer_);
	this->peer_table.empty();
	return 0;
}

//........................................................................................
int
SimpleController::handle_timeout (const ACE_Time_Value &tv, const void *arg)
{
	ACE_TRACE("SimpleController::handle_timeout");

	int time_tag = static_cast <int> (reinterpret_cast <size_t> (arg));
	ACE_UNUSED_ARG(tv);


	if ( time_tag ==  SimpleController::STARTUP )
	{
		this->start_timer_ = -1;
		this->startsim_action();
	}
	else
	{
		ACE_DEBUG ((LM_ERROR, "(%P|%t) SimpleController::handle_timeout  ERROR no action (%d)\n",time_tag));
	}

	// Must return a zero to continue
	return 0;
}


//........................................................................................
//  Action from the "handle_timeout"
int SimpleController::startsim_action(void)
{
	ACE_TRACE("SimpleController::startsim_action");

	if ( !Samson_Peer::SAMSON_OBJMGR::instance ()->checkPeersStarted (peer_table) )
	{
		this->schedule_start(3);
	}
	else  // we're ready...send out the message
	{
		ACE_DEBUG ((LM_ERROR, "(%P|%t) SimpleController::startsim_action -> sending InitCase\n"));
		this->sendCtrlMsg (SimMsgType::LOG_EVENT_CHANNEL_STATUS, SimMsgFlag::job);;
		this->print ();
		// SamsonModel subscribes to this message (goes to all models in this job)
		this->sendInitCase ();
	}

	return 1;
}

//........................................................................................
void
SimpleController::print()
{
	ACE_DEBUG ((LM_INFO,
		"(%P|%t) SimpleController::print"
		"\n-------------------------------------------------------------\n"
	));
	this->peer_table.print();
}


//.........................................................................................
//.........................................................................................
//  Object Message:  mInitEvent
//  This is send by the dispatcher ??
int SimpleController::doInitEvent(Samson_Peer::MessageBase *)
{
	ACE_TRACE("SimpleController::doInitEvent");
	return 1;
}

//.........................................................................................
//  Process End of Engagement Event
int SimpleController::doEndEngagement(Samson_Peer::MessageBase *)
{
		ACE_DEBUG ((LM_INFO, "(%P|%t) SimpleController::doEndEngagement(%D) -> sending End Run\n"));
		std::string verbose("verbose");
		this->sendDispatcherCommand(verbose);

		// End the run
		this->sendEndRun();

	return 0;
}

//.........................................................................................
// ObjectMessage: mEndRunCmp
int SimpleController::doEndRunComplete(Samson_Peer::MessageBase *mb)
{
	ACE_TRACE("SimpleController::doEndRunComplete");

	const SamsonHeader *sh = mb->get_header();
	//if (DebugFlag::instance ()->enabled (DebugFlag::APB_DEBUG))
	{
		ACE_DEBUG ((LM_INFO, "(%P|%t) SimpleController::doEndRunComplete(%D) ->"));
		sh->print();
	}

	endGame_ = true;

	// process if not me!
	if (this->model_id_ != sh->peer_id () )
	{

		PeerTable::PeerMapIterator iter;
		for (iter = peer_table.begin(); iter != peer_table.end(); iter++)
		{
			PeerRecord *a = iter->second;
			if ( a->peer_id == sh->peer_id () &&  !a->powered_down )
			{
				a->powered_down = true;
			}
#if 0
			else
			{
				ACE_DEBUG ((LM_INFO, "(%P|%t) SimpleController::doEndRunComplete (Job:%d Msg:%d(%d) Mdl:%d-%d) -> Model(%d) not found\n",
					sh->run_id(), sh->message_id(), sh->app_msg_id(), sh->peer_id(), sh->unit_id(),
					sh->peer_id()));
			}
#endif
		}

	}


	// Now to shut it all down, if all the others are all ready to be shutdown
	{
		bool shut_me_down = true;
		PeerTable::PeerMapIterator iter;
		for (iter = peer_table.begin(); iter != peer_table.end(); iter++)
		{
			PeerRecord *a = iter->second;
			if ( a->peer_id != this->model_id_ &&  !a->powered_down )
			{
				shut_me_down = false;
				break;
			}
		}
		if ( shut_me_down )
		{
				ACE_DEBUG ((LM_INFO, "(%P|%t) SimpleController::doEndRunComplete - shutting down all the models\n"));
				this->stopSimulation();
		}
	}


	return 1;

}


// ====================================
ACE_FACTORY_DECLARE(ISE,SimpleController)
